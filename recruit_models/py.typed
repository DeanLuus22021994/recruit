"""
Advanced Type Configuration for Recruit Models Package

This file serves as a PEP 561 marker and provides comprehensive type information
for the recruit_models package, enhancing IDE support, type checking, and
developer experience in 2025.

Features:
- Full PEP 561 compliance
- Django ORM type integration
- Protocol type exports
- Runtime type checking configuration
- IDE enhancement metadata
- Error handling type definitions
- Generic type support
- Backwards compatibility
"""

from __future__ import annotations

import sys
from typing import (
    TYPE_CHECKING,
    Any,
    ClassVar,
    Dict,
    Final,
    List,
    Literal,
    Optional,
    Protocol,
    Tuple,
    Type,
    TypeAlias,
    TypeVar,
    Union,
    runtime_checkable,
)

# PEP 561 compliance markers
__pep561__: Final[bool] = True
__type_complete__: Final[bool] = True

# Package metadata
__version__: Final[str] = "1.0.0"
__author__: Final[str] = "Recruit Development Team"
__django_version__: Final[str] = "5.0+"
__python_version__: Final[str] = "3.12+"
__last_updated__: Final[str] = "2025-06-15"

# Type checker compatibility
MYPY_VERSION_REQUIRED: Final[str] = "1.8+"
PYRIGHT_VERSION_REQUIRED: Final[str] = "1.1.350+"
PYLANCE_SUPPORTED: Final[bool] = True

# Generic type variables for Django models
_ModelT = TypeVar("_ModelT", bound="models.Model")
_UserT = TypeVar("_UserT", bound="User")
_QuerySetT = TypeVar("_QuerySetT", bound="models.QuerySet[Any]")
_ManagerT = TypeVar("_ManagerT", bound="models.Manager[Any]")

# Django field type aliases for better inference
ModelFieldType: TypeAlias = Union[
    "models.CharField",
    "models.TextField",
    "models.IntegerField",
    "models.BooleanField",
    "models.DateTimeField",
    "models.DateField",
    "models.EmailField",
    "models.ImageField",
    "models.FileField",
    "models.URLField",
    "models.SlugField",
    "models.UUIDField",
    "models.JSONField",
    "models.DecimalField",
    "models.FloatField",
    "models.BigIntegerField",
    "models.SmallIntegerField",
    "models.PositiveIntegerField",
    "models.ForeignKey[Any, Any]",
    "models.OneToOneField[Any, Any]",
    "models.ManyToManyField[Any]",
]

# Signal handler type alias
SignalHandlerType: TypeAlias = "Callable[[Any, Any, bool], None]"

# Choice field type aliases
ChoiceType: TypeAlias = Tuple[str, str]
ChoicesType: TypeAlias = Tuple[ChoiceType, ...]
StatusChoiceType: TypeAlias = Tuple[int, str]
StatusChoicesType: TypeAlias = Tuple[StatusChoiceType, ...]

# File upload type aliases
ImageUploadType: TypeAlias = Union[
    "models.ImageField", "InMemoryUploadedFile", "TemporaryUploadedFile"
]
FileUploadType: TypeAlias = Union[
    "models.FileField", "InMemoryUploadedFile", "TemporaryUploadedFile"
]


# Error handling types
class ModelValidationError(Exception):
    """Custom exception for model validation errors."""

    pass


class TypeCheckError(Exception):
    """Custom exception for type checking errors."""

    pass


# Runtime type checking configuration
@runtime_checkable
class TypeCheckingConfig(Protocol):
    """Protocol for type checking configuration."""

    strict_mode: bool
    django_integration: bool
    protocol_checking: bool
    generic_support: bool
    error_reporting: bool


class AdvancedTypeConfig:
    """Advanced configuration class for type checking tools and IDEs."""

    # Core configuration
    STRICT_MODE: Final[bool] = True
    DJANGO_INTEGRATION: Final[bool] = True
    PROTOCOL_CHECKING: Final[bool] = True
    GENERIC_SUPPORT: Final[bool] = True
    ERROR_REPORTING: Final[bool] = True

    # Django app configuration
    DJANGO_APPS: Final[Tuple[str, ...]] = (
        "accounts",
        "candidates",
        "employers",
        "interviews",
        "jobs",
        "recruiters",
        "sendgrid",
    )

    # Model categorization for better organization
    MODEL_CATEGORIES: Final[Dict[str, Tuple[str, ...]]] = {
        "user_models": ("UserProfile", "Candidate", "Employer", "Recruiter"),
        "requirement_models": (
            "CandidateRequirements",
            "EmployerRequirements",
            "JobRequirements",
        ),
        "document_models": ("CandidateDocument", "EmployerImages"),
        "workflow_models": (
            "InterviewInvitation",
            "InterviewRequest",
            "Available",
            "Exclusion",
        ),
        "content_models": ("Job", "Country", "EmailTemplate", "EmailLog"),
    }

    # Model relationship mapping
    USER_RELATED_MODELS: Final[Tuple[str, ...]] = (
        "UserProfile",
        "Candidate",
        "Employer",
        "Recruiter",
    )

    FOREIGN_KEY_MODELS: Final[Tuple[str, ...]] = (
        "CandidateDocument",
        "EmployerImages",
        "InterviewInvitation",
        "InterviewRequest",
        "Job",
        "JobRequirements",
        "EmailLog",
    )

    ONE_TO_ONE_MODELS: Final[Tuple[str, ...]] = (
        "UserProfile",
        "CandidateRequirements",
        "EmployerRequirements",
        "JobRequirements",
    )

    # Field type mappings for validation
    REQUIRED_FIELDS: Final[Dict[str, Tuple[str, ...]]] = {
        "Candidate": ("user", "birth_year"),
        "Employer": ("user", "phone_number", "name_english", "name_local"),
        "Job": ("employer", "title", "weekly_hours", "salary_high", "salary_low"),
        "EmailLog": ("recipient", "sender", "subject"),
    }

    OPTIONAL_FIELDS: Final[Dict[str, Tuple[str, ...]]] = {
        "Candidate": ("date_of_birth", "gender", "education", "education_major"),
        "UserProfile": ("timezone", "skype_id"),
        "Job": ("location", "contract_renew_bonus", "contract_completion_bonus"),
    }

    # Image/File field configurations
    IMAGE_FIELDS: Final[Dict[str, Tuple[str, ...]]] = {
        "Candidate": ("image", "thumb"),
        "Employer": ("business_license", "business_license_thumb"),
        "EmployerImages": ("image", "thumb"),
        "Recruiter": ("image", "thumb"),
    }

    FILE_FIELDS: Final[Dict[str, Tuple[str, ...]]] = {
        "CandidateDocument": ("document",),
    }

    # Choice field definitions
    CHOICE_FIELDS: Final[Dict[str, str]] = {
        "gender": "GENDER_CHOICES",
        "education": "EDUCATION_CHOICES",
        "employer_type": "EMPLOYER_TYPE_CHOICES",
        "status": "EMAIL_STATUS_CHOICES",
        "user_type": "USER_TYPE_CHOICES",
        "location": "LOCATION_CHOICES",
        "compensation_type": "COMPENSATION_TYPE_CHOICES",
    }

    # Signal configuration
    SIGNAL_HANDLERS: Final[Dict[str, str]] = {
        "Candidate": "candidate_update_user_profile",
        "Employer": "employer_update_user_profile",
        "Recruiter": "recruiter_update_user_profile",
        "InterviewRequest": "generate_invitation",
        "User": "create_account_emailaddress",
    }


# Type checking imports (only loaded during static analysis)
if TYPE_CHECKING:
    from typing import Callable

    from django.contrib.auth.models import User
    from django.core.files.uploadedfile import (
        InMemoryUploadedFile,
        TemporaryUploadedFile,
    )
    from django.db import models
    from django.db.models import QuerySet

    # Import all protocol types for comprehensive type checking
    from recruit_types.accounts import TokenVerificationResult, UserProfileType
    from recruit_types.candidates import (
        CandidateDocumentType,
        CandidateRequirementsType,
        CandidateType,
    )
    from recruit_types.employers import (
        EmployerImagesType,
        EmployerRequirementsType,
        EmployerType,
    )
    from recruit_types.interviews import (
        AvailableType,
        ExclusionType,
        InterviewInvitationType,
        InterviewRequestType,
        StatusChoiceType,
    )
    from recruit_types.jobs import (
        CountryType,
        JobRequirementsType,
        JobType,
    )
    from recruit_types.recruiters import RecruiterType
    from recruit_types.sendgrid import (
        EmailLogType,
        EmailTemplateType,
    )

    # Type exports for external consumption
    __all_types__: Final[Tuple[str, ...]] = (
        "UserProfileType",
        "TokenVerificationResult",
        "CandidateType",
        "CandidateRequirementsType",
        "CandidateDocumentType",
        "EmployerType",
        "EmployerRequirementsType",
        "EmployerImagesType",
        "InterviewInvitationType",
        "InterviewRequestType",
        "AvailableType",
        "ExclusionType",
        "CountryType",
        "JobType",
        "JobRequirementsType",
        "RecruiterType",
        "EmailTemplateType",
        "EmailLogType",
        "StatusChoiceType",
    )


# Runtime configuration for development tools
class DevelopmentConfig:
    """Configuration for development and debugging tools."""

    DEBUG_TYPE_CHECKING: Final[bool] = False
    VERBOSE_ERROR_REPORTING: Final[bool] = True
    PERFORMANCE_MONITORING: Final[bool] = True

    # IDE integration settings
    AUTOCOMPLETE_ENHANCED: Final[bool] = True
    REFACTORING_SUPPORT: Final[bool] = True
    CODE_NAVIGATION: Final[bool] = True

    # Linting and formatting
    MYPY_STRICT: Final[bool] = True
    PYLINT_INTEGRATION: Final[bool] = True
    BLACK_COMPATIBLE: Final[bool] = True
    ISORT_COMPATIBLE: Final[bool] = True


# Export main configuration classes
__type_config__: Final[Type[AdvancedTypeConfig]] = AdvancedTypeConfig
__dev_config__: Final[Type[DevelopmentConfig]] = DevelopmentConfig


# Version compatibility checks
def _check_python_version() -> bool:
    """Check if Python version meets requirements."""
    return sys.version_info >= (3, 12)


def _check_typing_extensions() -> bool:
    """Check if typing_extensions is available for older Python versions."""
    try:
        import typing_extensions  # noqa: F401

        return True
    except ImportError:
        return False


# Runtime checks (only if not in type checking mode)
if not TYPE_CHECKING:
    PYTHON_VERSION_OK: Final[bool] = _check_python_version()
    TYPING_EXTENSIONS_OK: Final[bool] = _check_typing_extensions()

    if not PYTHON_VERSION_OK:
        import warnings

        warnings.warn(
            f"Python {__python_version__} or higher is recommended for full type support",
            UserWarning,
            stacklevel=2,
        )

# Final exports for type checkers and runtime
__all__: Final[List[str]] = [
    # Configuration classes
    "AdvancedTypeConfig",
    "DevelopmentConfig",
    "TypeCheckingConfig",
    # Type aliases
    "ModelFieldType",
    "SignalHandlerType",
    "ChoiceType",
    "ChoicesType",
    "StatusChoiceType",
    "StatusChoicesType",
    "ImageUploadType",
    "FileUploadType",
    # Exception classes
    "ModelValidationError",
    "TypeCheckError",
    # Metadata
    "__version__",
    "__author__",
    "__django_version__",
    "__python_version__",
]

# Ensure this file is recognized as a type stub
if not TYPE_CHECKING:
    # Add runtime marker for debugging
    __runtime_type_checking__ = False
else:
    __runtime_type_checking__ = True
